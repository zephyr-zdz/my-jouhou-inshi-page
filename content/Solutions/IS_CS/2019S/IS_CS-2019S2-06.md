# IS CS-2019S2-06

**题目来源**：[[2019S2#Problem 6]]
**日期**：2024-08-03
**题目主题**：CS-算法-决策问题

## 解题思路

这道题目涉及三个决策问题 A、B 和 C，分别关于数组中的两数之和、三数之和为零、以及平面上三点共线的判定。我们需要设计算法、分析复杂度，并且证明问题之间的关系。解题过程中会用到双指针、哈希表、代数技巧等方法。

## Solution

### 1. Algorithm for Problem A

To solve Problem A in $O(n)$ time, we can use the two-pointer technique, taking advantage of the fact that the array is sorted.

```python
def solve_problem_A(S, c):
    left, right = 0, len(S) - 1
    while left < right:
        current_sum = S[left] + S[right]
        if current_sum == c:
            return True
        elif current_sum < c:
            left += 1
        else:
            right -= 1
    return False
```

This algorithm works as follows:

1. Initialize two pointers, `left` at the beginning and `right` at the end of the array.
2. While `left` is less than `right`:
   a. Calculate the sum of `S[left]` and `S[right]`.
   b. If the sum equals `c`, we've found a solution, return `True`.
   c. If the sum is less than `c`, increment `left` to increase the sum.
   d. If the sum is greater than `c`, decrement `right` to decrease the sum.
3. If we exit the loop without finding a solution, return `False`.

**Time complexity**: $O(n)$, as we traverse the array at most once.
**Space complexity**: $O(1)$, as we only use two pointers.

#### Proof of Correctness

We will prove this by contradiction. Suppose the greedy algorithm fails to find a solution $(s_i, s_j)$ such that $s_i + s_j = c$, even though such a solution exists.

Let $(s_p, s_q)$ be a pair that sums to $c$, where $p < q$. Consider the moment in our algorithm when the left pointer is at some position $l \leq p$ and the right pointer is at some position $r \geq q$.

1. If $l = p$ and $r = q$, the algorithm would have found the solution, contradicting our assumption.
2. If $l < p$ or $r > q$, we have three cases: a) If $S[l] + S[r] = c$, the algorithm would have found a solution, contradicting our assumption. b) If $S[l] + S[r] < c$, the algorithm moves the left pointer. This is the correct move because:

    - We know $S[p] + S[q] = c$
    - And $S[l] + S[r] < c$
    - Since $S$ is sorted, $S[l] \leq S[p]$ and $S[r] \geq S[q]$
    - Therefore, $S[l] + S[q] \leq S[p] + S[q] = c$
    - This means no element to the left of or at $l$ can sum with $S[q]$ to $c$
    - So, we must move the left pointer to find a potential solution.

3. If $S[l] + S[r] > c$, the algorithm moves the right pointer. This is the correct move because:

    - We know $S[p] + S[q] = c$
    - And $S[l] + S[r] > c$
    - Since $S$ is sorted, $S[l] \leq S[p]$ and $S[r] \geq S[q]$
    - Therefore, $S[p] + S[r] \geq S[p] + S[q] = c$
    - This means no element to the right of or at $r$ can sum with $S[p]$ to $c$
    - So, we must move the right pointer to find a potential solution.

In all cases, the algorithm makes the correct decision to move towards the solution $(s_p, s_q)$. This contradicts our initial assumption that the algorithm fails to find a solution when one exists.

Therefore, if a solution exists, the greedy algorithm will always find it. If the algorithm doesn't find a solution, we can conclude that no solution exists.

### 2. Algorithm for Problem B

To solve Problem B in $O(n^2)$ time, we can use a hash table to store the negation of the sum of two elements, then check if the third element exists in the hash table.

```python
def solve_problem_B(T):
    T = sorted(T)  # Sort the array first
    for i in range(len(T) - 2):
        if i > 0 and T[i] == T[i-1]:
            continue  # Skip duplicates
        left, right = i + 1, len(T) - 1
        while left < right:
            total = T[i] + T[left] + T[right]
            if total == 0:
                return True
            elif total < 0:
                left += 1
            else:
                right -= 1
    return False
```

This algorithm works as follows:

1. Sort the array `T` (this takes $O(n \log n)$ time, which is dominated by $O(n^2)$).
2. Iterate through the array with index `i` from $0$ to $n-3$.
3. For each `i`, use two pointers `left` and `right` to find if there exist `j` and `k` such that $T[i] + T[j] + T[k] = 0$.
4. If found, return `True`. If not found after checking all possibilities, return `False`.

**Time complexity**: $O(n^2)$, as we have a nested loop structure.
**Space complexity**: $O(1)$ if we don't count the space for sorting, $O(n)$ if we do.

### 3. Expressing c in terms of a and b

To express $c$ using $a$ and $b$ for the points $(a, a^3)$, $(b, b^3)$, and $(c, c^3)$ being collinear:

The points are collinear if the slope between any two pairs of points is the same. The slope between $(a, a^3)$ and $(c, c^3)$ is:

$$

\frac{c^3 - a^3}{c - a} = c^2 + ca + a^2

$$

The slope between $(b, b^3)$ and $(c, c^3)$ is:

$$

\frac{c^3 - b^3}{c - b} = c^2 + cb + b^2

$$

Setting the slopes equal gives:

$$

c^2 + ca + a^2 = c^2 + cb + b^2

$$

Simplifying, we get:

$$

a^2 + ac = b^2 + bc

$$

Solving for $c$:

$$

c = \frac{a^2 - b^2}{b - a} = - a -b

$$

### 4. Proving no $O(n)$ algorithm for Problem C

We will prove this by contradiction. Assume there exists an $O(n)$ algorithm for Problem C. We'll show that this would imply an $O(n)$ algorithm for Problem B, contradicting the given assumption.

**Proof**:

1) Suppose we have an $O(n)$ algorithm $A_C$ for Problem **C**.

2) Given an instance of Problem **B** with set $T = \{t_1, t_2, …, t_n\}$, we can transform it into an instance of Problem **C** as follows:
   For each $t_i \in T$, create a point $(t_i, t_i^3)$ in the 2D plane.
   Let this set of points be $P = \{(t_1, t_1^3), (t_2, t_2^3), …, (t_n, t_n^3)\}$.

3) Now, we claim that there exist $i, j, k$ such that $t_i + t_j + t_k = 0$ if and only if the corresponding points $(t_i, t_i^3), (t_j, t_j^3), (t_k, t_k^3)$ are collinear.

	To prove this claim:

	- If $t_i + t_j + t_k = 0$, then $t_k = -(t_i + t_j)$.
	- The points $(t_i, t_i^3), (t_j, t_j^3), (-(t_i+t_j), -(t_i+t_j)^3)$ are collinear because they satisfy the equation we derived in Question 3.
	- Conversely, if three points $(a, a^3), (b, b^3), (c, c^3)$ are collinear, then from our result in Question 3, we know that one of them must be the negative sum of the other two.

4) Therefore, we can solve Problem **B** by:
   - Transforming the input of **B** to an input of **C** (takes $O(n)$ time)
   - Running algorithm $A_C$ on this input (takes $O(n)$ time by assumption)
   - Interpreting the result of $A_C$ as the result for **B** (takes $O(1)$ time)

5) This would give us an $O(n)$ algorithm for Problem **B**, which contradicts our assumption that no such algorithm exists.

Therefore, our initial assumption must be false, and there cannot exist an $O(n)$ algorithm for Problem **C** under the given conditions.

## 知识点

#两数之和 #双指针 #哈希表 #复杂度分析 #反证法

## 难点思路

问题 3 和问题 4 可能是较难的部分。问题 3 需要仔细的代数推导，而问题 4 需要构造一个巧妙的转化来建立问题 B 和问题 C 之间的联系。

## 解题技巧和信息

1. 对于排序数组的两数之和问题，双指针方法通常是最优解。
2. 对于三数之和问题，可以固定一个数，然后在剩余数中寻找两数之和，这样可以将复杂度从 O(n^3) 降低到 O(n^2)。
3. 在处理几何问题时，利用点斜式方程或者向量的方法通常很有帮助。
4. 在证明算法复杂度下界时，归约（reduction）是一个强大的工具。如果我们可以在线性时间内将一个已知的 " 困难 " 问题转化为目标问题，那么目标问题就不可能有比这个 " 困难 " 问题更优的解法。

## 重点词汇

two-pointer technique 双指针技巧

hash table 哈希表

collinearity 共线性

quadratic equation 二次方程

proof by contradiction 反证法

reduction 归约

## 参考资料

1. Introduction to Algorithms (CLRS), Chapter 2 (Getting Started) and Chapter 33 (Computational Geometry)
2. Algorithm Design Manual by Steven Skiena, Chapter 2 (Algorithm Analysis) and Chapter 17 (Computational Geometry)
3. Competitive Programmer's Handbook by Antti Laaksonen, Chapter 5 (Complete Search)
