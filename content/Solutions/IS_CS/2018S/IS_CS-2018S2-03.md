# IS CS-2018S2-03

**题目来源**：[[2018S2#Problem 3]]
**日期**：2024-08-10
**题目主题**：CS-算法-二叉树与递归

## 解题思路

我们面对的是一个特殊的 AVL 树 $T_n$，这个二叉树有如下性质：

1. 每个叶子节点的高度为 $0$。
2. 每个非叶子节点 $v$ 的高度是 $\max_{w \in L(v)} p(v, w)$。
3. 节点 $v$ 可能有以下三种类型：
   - $v$ 是一个叶子节点。
   - $v$ 只有一个子节点，并且 $v$ 的高度为 $1$。
   - $v$ 有两个子节点，并且这两个子节点的高度相差 $1$。

题目要求我们求出 $T_n$ 的节点总数 $N_n$，以及在 $N_n$ 与黄金比例 $r = \frac{1 + \sqrt{5}}{2}$ 之间建立一些不等式关系。最终，我们还需要设计一个算法来为这些节点分配整数。

## Solution

### Q1: Calculate $N_5$

To calculate $N_5$, we first observe the following pattern based on the problem's constraints:

- $N_0 = 1$ (a single leaf node).
- $N_1 = 2$ (one internal node with height $1$ and one leaf node).

From the problem's constraints, we see that:

$$
N_n = 1 + N_{n-1} + N_{n-2} \text{ for } n \geq 2
$$

Given the recursive relationship, we calculate $N_5$ as follows:

$$

\begin{aligned}

N_0 & = 1, \\

N_1 & = 2, \\

N_2 & = 1 + N_1 + N_0 = 4, \\

N_3 & = 1 + N_2 + N_1 = 7, \\

N_4 & = 1 + N_3 + N_2 = 12, \\

N_5 & = 1 + N_4 + N_3 = 20.

\end{aligned}

$$

Thus, $N_5 = 20$.

### Q2: Express $N_n$ in terms of $N_{n-1}$ and $N_{n-2}$ for $n \geq 2$

The recurrence relation for $N_n$ is derived as follows:

$$
N_n = 1 + N_{n-1} + N_{n-2}
$$

This relation reflects the sum of nodes for the tree of height $n$ where the root contributes one node, and the subtrees contribute nodes according to the heights $n-1$ and $n-2$.

### Q3: Prove that $N_n \geq r^n$ for every $n \geq 0$

To prove this inequality by induction:

**Base Cases:**

- $N_0 = 1 \geq r^0 = 1$
- $N_1 = 2 \geq r^1 = r \approx 1.618$

**Inductive Step:**

Assume $N_k \geq r^k$ for $k \leq n-1$. For $N_n$:

$$
N_n = 1 + N_{n-1} + N_{n-2} \geq 1 + r^{n-1} + r^{n-2}.
$$

We need to show:

$$
1 + r^{n-1} + r^{n-2} \geq r^n.
$$

Using the property of $r$:

$$
r^n = r^{n-1} + r^{n-2}.
$$

Thus:

$$
1 + r^{n-1} + r^{n-2} \geq r^n.
$$

This completes the proof.

### Q4: Prove that $N_n \leq r^{n+2}$ for every $n \geq 0$

We now prove by induction that $N_n \leq r^{n+2}$.

**Base Cases:**

- $N_0 + 1 = 2 \leq r^2 \approx 2.618$
- $N_1 + 1 = 3 \leq r^3 \approx 4.236$

**Inductive Step:**

Assume for $n \geq 2$, $N_k + 1 \leq r^{k+2}$ holds for all $k \leq n-1$. For $N_n$:

$$

N_n + 1  = (N_{n-1} + 1) + (N_{n-2} + 1) \leq r^{n+1} + r^n

$$

Using the fact that $r^{n+2} = r^{n+1} + r^n$:

$$

N_n \leq r^{n+1} + r^n - 1 < r^{n+2} 

$$

Thus, $N_n \leq r^{n+2}$ for all $n \geq 0$.

### Q5: Show an $O(r^n)$ algorithm that computes such an assignment, with proof that it runs indeed in $O(r^n)$ time

#### 1. Algorithm Description

We are tasked with constructing an AVL tree of height $n$ while assigning integers to each node such that the AVL properties are preserved. By precomputing subtree sizes using dynamic programming, the assignment process can be streamlined.

**Algorithm Steps**:

1. **Precompute Subtree Sizes**: Use dynamic programming to calculate the sizes of all subtrees up to height $n$. Define `size(h)` to store the size of a tree of height $h$:

   $$
   \text{size}[h] = 
   \begin{cases} 
   1, & \text{if } h = 0,\\
   1 + \text{size}[h-1] + \text{size}[h-2], & \text{if } h > 0.
   \end{cases}
   $$

   This step runs in $O(n)$ time.

2. **Main Function `fillTree(arr, h)`**:
   - Base case: if $h = 0$, return a tree with a single node containing the first element of `arr`.
   - Calculate the sizes for left and right subtrees using the precomputed `size[h]`:

     $$
     \text{leftSize} = \text{size}[h-1], \quad \text{rightSize} = \text{size}[h-2]
     $$

   - Use `quickSelect` to find the $(\text{leftSize} + 1)$th smallest element in `arr` to be the root.
   - Recursively fill the left subtree with the smallest `leftSize` elements, and the right subtree with the largest `rightSize` elements.
   - Return the tree.

3. **QuickSelect**: This algorithm finds the $k$th smallest element in an array in average $O(n)$ time. It uses a pivot to partition the array and recursively selects the $k$th element from the appropriate partition.

#### 2. Complexity Analysis Using Akra-Bazzi Theorem

To rigorously analyze the time complexity of constructing the AVL tree, we use the **Akra-Bazzi Theorem**, which is a generalization of the Master Theorem and is more suitable for handling recurrences with multiple recursive branches and non-uniform problem sizes.

##### Recurrence Relation

The time complexity $T(n)$ for constructing an AVL tree of height $n$ satisfies the following recurrence relation:

$$
T(n) = T\left(\frac{N_n}{r}\right) + T\left(\frac{N_n}{r^2}\right) + O(N_n),
$$

where $N_n$ is the number of nodes in the tree of height $n$, and $r = \frac{1 + \sqrt{5}}{2}$ is the golden ratio. Since $N_n \approx c \cdot r^n$, the recurrence can be rewritten in terms of $N$:

$$
T(N) = T\left(\frac{N}{r}\right) + T\left(\frac{N}{r^2}\right) + O(N).
$$

##### Applying the Akra-Bazzi Theorem

The **Akra-Bazzi** Theorem is a variation of the **Master Theorem**, used to solve recurrences of the form:

$$
T(x) = g(x) + \sum_{i=1}^{k} a_i T(b_i x + h_i(x)),
$$

where:

- $g(x) = \Theta(x^c)$,
- $a_i > 0$,
- $0 < b_i < 1$,
- $h_i(x) = O(x / \log^2 x)$.

The solution to the recurrence is given by:

$$
T(x) = \Theta \left( x^p \left(1 + \int_{1}^{x} \frac{g(u)}{u^{p+1}} \mathrm{d}u \right) \right)
$$

where $p$ is the unique real solution to:

$$
\sum_{i=1}^{k} a_i b_i^p = 1.
$$

##### Determine Parameters for the Akra-Bazzi Theorem

In our recurrence:

- $g(N) = O(N)$ (since $f(N) = O(N)$),
- $a_1 = a_2 = 1$ (from the two recursive calls),
- $b_1 = \frac{1}{r}$ and $b_2 = \frac{1}{r^2}$,
- $h_i(N) = 0$ (no additional terms in the subproblems).

##### Solving for $p$

We solve for $p$ using the equation:

$$
\left(\frac{1}{r}\right)^p + \left(\frac{1}{r^2}\right)^p = 1.
$$

Given that $r$ is the golden ratio, we can simplify the equation:

$$
r^{-p} + r^{-2p} = 1.
$$

Multiply through by $r^{2p}$:

$$
r^p + 1 = r^{2p}.
$$

Taking the logarithm:

$$
\log(r^p + 1) = 2p \log(r),
$$

we find that $p = 1$ satisfies the equation.

##### Final Complexity

With $p = 1$, the integral term in the **Akra-Bazzi** Theorem solution does not introduce additional logarithmic factors, leading to:

$$
T(N) = O(N).
$$

Since $N_n \in O(r^n)$, the time complexity in terms of the height $n$ is:

$$
T(n) = O(r^n).
$$

##### Conclusion

By applying the Akra-Bazzi Theorem and solving for $p$, we rigorously confirm that the time complexity for constructing the AVL tree and assigning integers is indeed $O(r^n)$. This approach accurately captures the growth rate of the recursive calls and the work done at each step, leading to a precise complexity analysis.

## 知识点

#AVL树 #递归关系 #黄金比例 #平衡二叉树 #斐波那契数列 #主定理

## 难点思路

该问题的难点在于证明节点数量 $N_n$ 与黄金比例 $r$ 之间的不等式关系。这要求对递归公式有深刻理解，并且要熟悉黄金比例的一些特殊性质。此外，理解 AVL 树的平衡条件对于推导 $N_n$ 的递归公式至关重要，这一推导不仅解释了 AVL 树的平衡性如何影响节点数量，还揭示了其与斐波那契数列之间的联系。

## 解题技巧和信息

- 当处理递归关系时，特别是在树形结构中，寻找类似斐波那契数列的关系是一种有效的方法。
- 使用数学归纳法来证明递归关系通常是必要的，尤其是当需要证明不等式时。
- **理解 AVL 树的平衡条件**，不仅有助于推导节点数量递归公式，还帮助解释为什么 AVL 树的时间复杂度能保持在 $O(\log n)$。
- Akra-Bazzi 定理是处理这种不均等递归关系的强大工具，尤其是在分析时间复杂度时。

## 重点词汇

- AVL 树 (AVL Tree)
- 递归 (Recursion)
- 黄金比例 (Golden Ratio)
- 数学归纳法 (Mathematical Induction)
- 时间复杂度 (Time Complexity)
- 平衡二叉树 (Balanced Binary Tree)
- 斐波那契数列 (Fibonacci Sequence)

## 参考资料

1. Introduction to Algorithms, 3rd Edition, by Cormen, Leiserson, Rivest, and Stein - Chapter 12 (Binary Search Trees) and Chapter 4 (Recurrences)
2. Algorithm Design by Jon Kleinberg and Éva Tardos - Chapter 6 (Dynamic Programming)
3. Data Structures and Algorithm Analysis in C by Mark Allen Weiss - Chapter 4 (Balanced Trees)
