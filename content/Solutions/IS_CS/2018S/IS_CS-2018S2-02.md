# IS CS-2018S2-02

**题目来源**：[[2018S2#Problem 2]]
**日期**：2024-08-10
**题目主题**：CS-算法/形式语言与自动机

## Solution

### Question 1

To show that if $\alpha, \beta \in T$ and $\alpha \leftrightarrow^* \beta$, then there exists $\delta \in T$ such that $\alpha \Rightarrow^* \delta$ and $\beta \Rightarrow^* \delta$:

**Proof**:

1. The relation $\alpha \leftrightarrow^* \beta$ means that there exists a sequence of terms $\alpha = \gamma_0, \gamma_1, \dots, \gamma_n = \beta$ such that for each $i$, $\gamma_i \Rightarrow \gamma_{i+1}$ or $\gamma_{i+1} \Rightarrow \gamma_i$.
2. We will show that for any such sequence, there exists a term $\delta$ such that both $\alpha \Rightarrow^* \delta$ and $\beta \Rightarrow^* \delta$.
3. Consider $\gamma_0 = \alpha$. If $\gamma_1$ is obtained by applying a rule to $\gamma_0$, let $\delta_1 = \gamma_1$. Since $\gamma_1 \Rightarrow^* \delta_1$, we have $\alpha \Rightarrow^* \delta_1$.
4. If $\gamma_1 \Rightarrow \gamma_0$, then let $\delta_1 = \gamma_0$. Here, we also have $\alpha \Rightarrow^* \delta_1$ and $\gamma_1 \Rightarrow^* \delta_1$.
5. Now consider $\gamma_2$. By the same logic, there exists a term $\delta_2$ such that $\gamma_1 \Rightarrow^* \delta_2$ and $\gamma_2 \Rightarrow^* \delta_2$.
6. Continuing this process for the entire sequence $\gamma_0, \gamma_1, \dots, \gamma_n = \beta$, we eventually find a term $\delta = \delta_n$ such that both $\alpha \Rightarrow^* \delta$ and $\beta \Rightarrow^* \delta$.

Thus, for any pair $\alpha \leftrightarrow^* \beta$, there exists a term $\delta \in T$ such that $\alpha \Rightarrow^* \delta$ and $\beta \Rightarrow^* \delta$.

### Question 2

**Algorithm** to judge $\alpha \leftrightarrow^* \beta$ for $\alpha, \beta \in T$:

1. **Initialization**: Start with $\alpha$ and $\beta$ as input terms.
2. **Sequence Construction**: Construct the sequence of terms $\alpha = \gamma_0, \gamma_1, \dots, \gamma_n = \beta$ where each step involves applying a rewrite rule from $G$ either forwards or backwards.
3. **Forward and Backward Application**: At each step, check if applying a forward rule ($\Rightarrow$) or a backward rule ($\leftarrow$) can produce the next term in the sequence. If neither is possible, terminate with a negative result.
4. **Termination**: If a sequence connecting $\alpha$ to $\beta$ is found, return true (they are related by $\leftrightarrow^*$). Otherwise, return false.

**Correctness**:

The algorithm works because it explicitly checks for a sequence of forward and backward applications of rules that connect $\alpha$ to $\beta$. Since $\leftrightarrow^*$ is the reflexive, transitive, and symmetric closure of $\Rightarrow$, the algorithm correctly captures this relationship by considering both directions of rule application.

### Question 3

**Algorithm** to judge $\alpha \approx \beta$ for $\alpha, \beta \in T$:

1. **Initialization**: Start with $\alpha$ and $\beta$ as input terms.
2. **Normalization**: For each term, find the normal form by applying the rewrite rules in $G$ until no more rules can be applied. Let these normal forms be $\alpha'$ and $\beta'$.
3. **Sub-term Extraction**: For each position $w \in \{L, R\}^*$, extract the sub-terms $\alpha'.w$ and $\beta'.w$.
4. **First Symbol Check**: For each pair of extracted sub-terms, if both are defined and start with a symbol from $F_0 \cup F_2$, compare these symbols.
5. **Decision**: If all such corresponding pairs have identical first symbols, return true (i.e., $\alpha \approx \beta$). Otherwise, return false.

**Correctness**:

The algorithm correctly judges $\alpha \approx \beta$ by comparing all possible sub-terms extracted according to the positions defined by $w \in \{L, R\}^*$. The normal form ensures that the terms are fully reduced before comparison, making the process accurate and consistent with the definition of $\approx$.

## 知识点

#形式语言与自动机 #重写系统 #等价判断

## 解题思路

这道题目主要考察以下几个计算机科学和形式语言理论中的知识点：

### 1. 重写系统（Rewrite Systems）

   - **定义**：重写系统是一种通过规则将表达式中的某些部分替换为另一种形式的系统。重写系统通常用于形式化推理、证明定理以及简化表达式。
   - **运用**：在这道题中，重写系统通过一组重写规则定义了如何将变量替换为常量或函数项。理解这些规则的运作方式以及如何应用它们是解题的基础。

### 2. 转换关系（Transformation Relations）

   - **定义**：
     - **$\Rightarrow$**：表示通过单次应用重写规则从一个项（term）变换到另一个项。
     - **$\Rightarrow^*$**：这是 $\Rightarrow$ 的自反传递闭包，意味着可以通过多次（或零次）应用重写规则从一个项变换到另一个项。
     - **$\leftrightarrow^*$**：这是 $\Rightarrow$ 的对称、自反、传递闭包，意味着两个项可以通过一系列的重写规则相互变换。
   - **运用**：题目的第一部分要求证明两个项如果在 $\leftrightarrow^*$ 关系下等价，则它们可以通过 $\Rightarrow^*$ 变换到同一个标准项。理解和使用这些转换关系的闭包性质是解决这个问题的关键。

### 3. 等价性判断（Equivalence Checking）

   - **定义**：等价性判断通常是指判断两个表达式在某种特定关系下是否等价。在这道题中，定义了两种等价关系：
     - **$\leftrightarrow^*$ 等价**：表示两个项可以通过一系列的重写规则互相转换。
     - **$\approx$ 等价**：更强的等价性要求，不仅在整体上等价，还要求在对应位置的子项也相同。
   - **运用**：题目要求设计算法来判断这两种等价性。这涉及到如何系统地应用规则，提取和比较项的子项，以及如何利用算法结构化地验证等价性。

### 4. 闭包操作（Closure Operations）

   - **定义**：闭包操作是数学上重要的概念，尤其在关系上。自反闭包、传递闭包、对称闭包等概念在定义复杂关系时非常有用。
   - **运用**：在题目中，$\Rightarrow^*$ 是 $\Rightarrow$ 的自反传递闭包，而 $\leftrightarrow^*$ 是 $\Rightarrow$ 的对称、自反、传递闭包。理解这些闭包操作是设计正确算法和证明等价性的重要工具。

### 5. 算法设计（Algorithm Design）

   - **定义**：设计算法以系统化地解决问题，是计算机科学的核心任务之一。算法的正确性和效率是两个关键考量因素。
   - **运用**：题目要求设计判断两个项是否等价的算法。这里需要通过逐步应用重写规则、检查标准形式和子项的一致性，来判断等价性。设计这个算法的过程包括如何有效地探索和验证所有可能的项的变换路径。

### 如何运用这些知识点

1. **理解题目定义的关系**：首先，需要理解 $\Rightarrow$，$\Rightarrow^*$，$\leftrightarrow^*$，以及 $\approx$ 这些关系的定义和它们之间的联系。这些定义为后续的证明和算法设计提供了理论基础。

2. **证明题目 1**：证明部分依赖于闭包操作的性质。具体来说，通过分析 $\leftrightarrow^*$ 的定义，可以得出存在一个共同的项，两个原始项都可以通过应用 $\Rightarrow^*$ 变换到该项。

3. **算法设计**：
   - **$\leftrightarrow^*$ 判定算法**：设计一个算法来判断两个项是否通过 $\leftrightarrow^*$ 等价。该算法需要模拟应用规则的过程，检查是否存在变换路径。
   - **$\approx$ 判定算法**：设计另一个算法来判断 $\approx$ 等价。该算法需要对每个可能的子项进行比较，并确保在所有相关位置上的符号都一致。

4. **子项提取和比较**：最后一个等价性判定问题还涉及如何正确提取并比较项的子项。这里需要按照定义中的规则逐步提取子项并进行符号比较。

通过综合运用这些知识点，按照严谨的数学推理和算法设计思路，才能完成这道题目的解答。

## 解题技巧和信息

1. **重写系统与等价性**: 通过找到一个共同的标准形式（normal form），可以更容易判断两个项之间的等价性。
2. **关系的闭包**: 要理解不同关系（如 $\Rightarrow^*$ 和 $\leftrightarrow^*$）之间的区别以及如何利用这些关系进行判定。

## 重点词汇

- Reflexive Closure: 自反闭包
- Transitive Closure: 传递闭包
- Symmetric Closure: 对称闭包
- Rewrite Rule: 重写规则
- Normal Form: 规范形式

## 参考资料

1. Hopcroft, J. E., Motwani, R., & Ullman, J. D. (2006). *Introduction to Automata Theory, Languages, and Computation*. Chapter on Rewrite Systems.
