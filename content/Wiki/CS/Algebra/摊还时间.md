# Amortized Time | 摊销时间 (摊还时间)

## Overview | 概述

**Amortized time** (also known as **amortized analysis** or **amortized cost**) is a method used in algorithm analysis to average the time complexity of operations over a sequence of operations, rather than focusing on the worst-case time complexity of a single operation. This approach is particularly useful in data structures where some operations might occasionally be costly, but are compensated by many other cheap operations.
**摊销时间**（也称为**摊还时间**或**摊销分析**）是一种算法分析方法，通过对一系列操作进行时间复杂度平均，而不是单纯关注单个操作的最坏情况时间复杂度。该方法在某些操作偶尔代价较高、但由许多其他廉价操作补偿的数据结构中尤其有用。

## Key Concepts | 关键概念

1. **Amortized Cost | 摊销成本**:
   - The average cost of an operation over a sequence of operations.
   - 一系列操作中单次操作的平均成本。

2. **Worst-case Time Complexity | 最坏情况时间复杂度**:
   - The maximum time complexity an operation could take in the worst scenario.
   - 操作在最坏情况下可能需要的最大时间复杂度。

3. **Potential Method | 势能法**:
   - A technique in amortized analysis where a potential function is defined to capture the "stored energy" of a data structure. The change in potential reflects the cost distribution among operations.
   - 摊销分析中的一种技术，通过定义一个势能函数来捕捉数据结构的“存储能量”。势能的变化反映了操作间成本的分布。

## Methods of Amortized Analysis | 摊销分析方法

### 1. Aggregate Analysis | 聚合分析

- **Definition | 定义**:
  - Calculate the total time for a sequence of operations, and then average this time across all operations.
  - 计算一系列操作的总时间，然后将其平均分配到每个操作上。
- **Example | 示例**:
  - Consider inserting $n$ items into a dynamic array. Resizing the array may be costly, but since it happens infrequently, the average cost per insertion is low.
  - 例如，将 $n$ 个元素插入一个动态数组中。数组的重新调整大小可能代价高昂，但由于它发生频率较低，平均每次插入的成本较低。

### 2. Accounting Method | 均摊分析

- **Definition | 定义**:
  - Assign a "charge" or "credit" to each operation, overcharging some operations to account for the cost of more expensive operations later.
  - 给每个操作分配“费用”或“信用”，超额收取一些操作的费用，以支付将来可能发生的更昂贵操作的成本。
- **Example | 示例**:
  - In a stack with an auxiliary operation that occasionally takes $O(n)$ time, you can assign a small constant cost to each push operation, accumulating enough credit to pay for the costly operation when it occurs.
  - 例如，在一个包含偶尔需要 $O(n)$ 时间的辅助操作的栈中，可以为每个压栈操作分配一个小的固定费用，积累足够的信用，以便在发生高成本操作时支付。

### 3. Potential Method | 势能法

- **Definition | 定义**:
  - Use a potential function to represent the "stored work" or "energy" in the data structure. The difference in potential between two states is used to account for the cost of operations.
  - 使用势能函数来表示数据结构中的“储存工作”或“能量”。两种状态之间的势能差用于解释操作的成本。
- **Example | 示例**:
  - In a Fibonacci Heap, the potential function could be defined as the number of trees in the root list plus twice the number of marked nodes. This potential is used to justify the $O(1)$ amortized cost of certain operations.
  - 例如，在斐波那契堆中，势能函数可以定义为根列表中树的数量加上标记节点数量的两倍。这个势能用于证明某些操作的 $O(1)$ 摊销成本。

## Why Amortized Analysis is Important | 摊销分析的重要性

1. **Realistic Performance | 更现实的性能**:
   - Amortized analysis provides a more realistic understanding of a data structure's performance over time, particularly in cases where operations vary in cost.
   - 摊销分析提供了对数据结构随时间变化的性能的更现实理解，特别是在操作成本变化较大的情况下。

2. **Efficiency in Dynamic Data Structures | 动态数据结构中的效率**:
   - In dynamic data structures, such as dynamic arrays, splay trees, or Fibonacci heaps, amortized analysis demonstrates that despite some operations being costly, the average operation is still efficient.
   - 在动态数据结构中，如动态数组、伸展树或斐波那契堆，摊销分析表明尽管某些操作成本较高，平均操作仍然是高效的。

3. **Algorithm Optimization | 算法优化**:
   - Understanding amortized time helps in designing algorithms that are optimized for sequences of operations rather than just individual ones.
   - 了解摊销时间有助于设计针对操作序列而非单个操作进行优化的算法。

## Common Examples | 常见示例

1. **Dynamic Array Resizing | 动态数组调整大小**
   - **Operation | 操作**: When a dynamic array is full, resizing it by doubling its size takes $O(n)$ time, but since this operation occurs infrequently, the amortized time per insertion is $O(1)$.
   - **操作**: 当动态数组已满时，将其大小加倍需要 $O(n)$ 时间，但由于这种操作很少发生，每次插入的摊销时间为 $O(1)$。

2. **Fibonacci Heap Operations | 斐波那契堆操作**
   - **Operation | 操作**: Decrease key and merge operations have an amortized time complexity of $O(1)$ due to the structure's lazy updates and potential method.
   - **操作**: 由于结构的懒惰更新和势能法，斐波那契堆的减小键值和合并操作具有 $O(1)$ 的摊销时间复杂度。

3. **Splay Trees | 伸展树**
   - **Operation | 操作**: In splay trees, the cost of operations is amortized over a sequence, ensuring that the average time per operation remains $O(\log n)$.
   - **操作**: 在伸展树中，操作的成本在一个操作序列中被摊销，确保每个操作的平均时间保持在 $O(\log n)$。

## Conclusion | 结论

**Amortized time** provides a powerful tool for analyzing the performance of algorithms, particularly in complex data structures where individual operations might vary significantly in cost. By focusing on the average time per operation across a sequence, amortized analysis offers a more practical assessment of an algorithm's efficiency.
**摊销时间**为分析算法性能提供了一种有力工具，特别是在复杂数据结构中单个操作成本可能差异较大的情况下。通过关注整个操作序列中每次操作的平均时间，摊销分析提供了一种更为实际的算法效率评估方式。
